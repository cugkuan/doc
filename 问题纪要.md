
# 图片上传

> java.net.ProtocolException: expected 4830 bytes but received 8192

在上传图片的时候，偶发性的报错，而且，这个问题只存在部分手机中。
 
 **原因**

图片上传的时候，给的size 大小 和实际上传的大小不一致，导致服务器关闭了流的传输。


造成这种情况，很多，可能是多个线程对文件进行读写，文件还没有写完，就开始上传了。

**解决方式**

能找到问题的原因更好，如果早不到问题的原因。最好的方式copy一份要上传的问题。上传copy的文件。


# content-length = -1 导致下载的逻辑问题


# koltin if else if 导致的问题


koltin的if else 是一个表达式，但是下面的代码会出现问题:

```java
  if (true){
        "1"
    }else if (false){
        "2"
    }else{
        "3"
    }.let {
        println(it)
    }
```

你会发现，没有任何输出


如果是下面这种写法

```
  if (true){
        "1"
    } else{
        "3"
    }.let {
        println(it)
    }
```
那么又是正常的


为什么会这样？猜测是 koltin 的bug ,这个bug 匪夷所思

# kolint 的 interface clone 接口问题



# 腾讯 x5 浏览，不支持浏览在线文档引发的问题。


当网页中，的某个链接地址是 pdf或者其它类型的文件时，由于腾讯x5 引擎处理不了于是 DownloadListener 会被回调，告诉你引擎处理不了，但是 问题代码就出现：

```java

   webView?.setDownloadListener { url: String?, userAgent: String?, contentDisposition: String?, mimetype: String?, contentLength: Long ->
            val intent = Intent()
            intent.action = "android.intent.action.VIEW"
            val contentUrl = Uri.parse(url)
            intent.data = contentUrl
            startActivity(intent)
        }

```

这样，造成了一个死循环了。


解决方式是，对于不能处理的文件直接走文件预览的流程。

# 部分 OPPO 和一加手机无法启动摄像头

代码如下：

```
 public void startOpenCameraVideo() {
        Intent cameraIntent = new Intent(MediaStore.ACTION_VIDEO_CAPTURE);
        if (cameraIntent.resolveActivity(getPackageManager()) != null) {
            File cameraFile = PictureFileUtils.createCameraFile(this, config.mimeType ==
                            PictureConfig.TYPE_ALL ? PictureConfig.TYPE_VIDEO : config.mimeType,
                    outputCameraPath, config.suffixType);
            cameraPath = cameraFile.getAbsolutePath();
            Uri imageUri = parUri(cameraFile);
            cameraIntent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);
            cameraIntent.putExtra(MediaStore.EXTRA_DURATION_LIMIT, config.recordVideoSecond);
            cameraIntent.putExtra(MediaStore.EXTRA_VIDEO_QUALITY, config.videoQuality);
            startActivityForResult(cameraIntent, PictureConfig.REQUEST_CAMERA);
        }
    }
```

上面的代码也是Android官方的写法，在大部分的手机上都没啥问题，但是偏偏部分的 OPPO 手机无法唤起


## 解决方法
 
  在manifest.xml中添加如下的配置
```html
   <queries>
        <intent>
            <action android:name="android.media.action.IMAGE_CAPTURE" />
        </intent>
    </queries>
```
https://developer.android.com/about/versions/11/privacy/package-visibility#all-apps

但是问题在于，摄像头一直作为系统应用的，应该满足其协议应用，但是，OPPO的新系统，确把拍照，摄像机做为一个应用级别的app了，需要配置软件包的可见性。真尼玛的坑1


# 字符串中，关于肉眼不可见，但是有长度的字符

 \u200b 

 这个字符的长度为 0

 
问题场景

在做二维码扫码的时候，扫到一个这样的二维码:

![image](./img/qr_test.png)


然后浏览无法跳转，扫除的二维码字符串如下:
​http://qm.qq.com/cgi-bin/qm/qr?k=ubrTTgpncqjEri8kxX67qfyBACSIemjf

怎么看都没什么问题。但最终发现，http前面还有一个'\u200b'的字符，但是肉眼不可见。

#  如何让Message 快速的被执行

Handler 同步屏障机制

一种简单的消息有限执行的机制。

https://blog.csdn.net/asdgbc/article/details/79148180


# EventBus 的代码阅读

核心的代码就是 EventBus 里面的代码；

  public void register(Object subscriber) 



在注册的时候，通过反射，找到接收event 的方法，然后封装成一个  Subscription。

post 的时候，就是找 Subscription 。

原理很简单。

# 关于获取状态栏高度的


测试提出一个 视觉bug ,在三星 s20+ 手机上，内容延伸到 状态栏下面，造成内容的遮挡。


于是我看到了这样的代码：

```
        private fun getLocalStatusBarHeight(context: Context): Int {
            var height = 0   
            val identifier = context.resources.getIdentifier("status_bar_height", "dimen", "android")
            var xdpi = context.resources.getDisplayMetrics().xdpi
            if (identifier > 0) {
                height = context.resources.getDimensionPixelSize(identifier)
            }
            if (height == 0) {
                height = context.resources.getDimensionPixelSize(R.dimen.common_54)
            }
            return height
        }
```

关键是这样一行

```
val identifier = context.resources.getIdentifier("status_bar_height", "dimen", "android")
```

显然，再部分手机上，获取的这个值是不正确的。


那么正确的方式是什么呢？


```
  public static void setOnApplyWindowInsetsListener(@NonNull final View v,
            final @Nullable OnApplyWindowInsetsListener listener) {
        if (Build.VERSION.SDK_INT >= 21) {
            Api21Impl.setOnApplyWindowInsetsListener(v, listener);
        }
    }
```

当然，当view 已经  成功绑定 window 后，可以这样的获取

```
    /**
     * Provide original {@link WindowInsetsCompat} that are dispatched to the view hierarchy.
     * The insets are only available if the view is attached.
     * <p>
     * On devices running API 20 and below, this method always returns null.
     *
     * @return WindowInsetsCompat from the top of the view hierarchy or null if View is detached
     */
    @Nullable
    public static WindowInsetsCompat getRootWindowInsets(@NonNull View view) {
        if (Build.VERSION.SDK_INT >= 23) {
            return Api23Impl.getRootWindowInsets(view);
        } else if (Build.VERSION.SDK_INT >= 21) {
            return Api21Impl.getRootWindowInsets(view);
        } else {
            return null;
        }
    }

```

Android 官方已经给出了解决方案，就是不查文档

## 延伸知识，关于 WindowInsets


inset 简单的理解，再全面屏幕时代，屏幕上有系统的状态栏，底部的导航栏。这些地方的尺寸需要有个东西去描述，inset 就是描述这个的尺寸。


参考资源：

https://mp.weixin.qq.com/s/DEI4bcmKkRBySUjO2AYEJA

https://developer.android.com/guide/topics/display-cutout?hl=zh-cn

https://medium.com/androiddevelopers/windowinsets-listeners-to-layouts-8f9ccc8fa4d1

https://juejin.cn/post/6844904006343458830


# WebView 奇异崩溃 

Using WebView from more than one process at once with the same data directory is not supported. https://crbug.com/558377

org.chromium.android_webview.AwBrowserProcess.b(PG:11)


这样的崩溃日志，根据Android 官方的说明

public static void setDataDirectorySuffix (String suffix)


Define the directory used to store WebView data for the current process. The provided suffix will be used when constructing data and cache directory paths. If this API is not called, no suffix will be used. Each directory can be used by only one process in the application. If more than one process in an app wishes to use WebView, only one process can use the default directory, and other processes must call this API to define a unique suffix.

This means that different processes in the same application cannot directly share WebView-related data, since the data directories must be distinct. Applications that use this API may have to explicitly pass data between processes. For example, login cookies may have to be copied from one process's cookie jar to the other using CookieManager if both processes' WebViews are intended to be logged in.

Most applications should simply ensure that all components of the app that rely on WebView are in the same process, to avoid needing multiple data directories. The disableWebView() method can be used to ensure that the other processes do not use WebView by accident in this case.

This API must be called before any instances of WebView are created in this process and before any other methods in the android.webkit package are called by this process.


那么处理也简单,在Application 中

```

 protected void attachBaseContext(Context base) {
       
            String processName = getProcessName();
            if (!TextUtils.equals(context.getPackageName(), processName)) {
                String  suffix = TextUtils.isEmpty(processName) ? getPackageName() : processName;
                WebView.setDataDirectorySuffix(suffix);
              
            }
    }



```

但是虽然这样处理，仍然有零星的一些崩溃，百思不得其解


考虑到：**当app崩溃的时候，一般会重启，这个时候，一个进程正在关闭，另一个进程正在重启，于是。。。**

https://www.yisu.com/zixun/445583.html

#  数据对比

看看下面的代码有没有问题

```
 Arrays.sort(points, new Comparator<int>() {
            @Override
            public int compare(int o1, int o2) {
                return o1 - o2;
            }
        });
```

咋一看 好像没啥问题，但是碰到 这样的数据 ,-2147483645 和 2147483647 对比的时候，就出错了，原因也很简单，越界了，也就是说，减法计算有越界的风险，正确的做法如下：

```
 Arrays.sort(points, new Comparator<int>() {
            @Override
            public int compare(int o1, int o2) {
                if(o1 > 0 && o2 <0){
                    return 1;
                }else if(o1 <0 && o2 >0){
                    return -1;
                }else{
                  return o1 - o2;
                }
            }
        });
```



