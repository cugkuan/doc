# 概述

队列和栈相对来说比较简单，但是单调队列需要认真的理解下。


滑动窗口问题，非常的典型。如何构造单调队列很关键。

# 滑动窗口问题

**题目描述**
给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。


![image](./img/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.png)


**思路**

- 如果使用双指针，每一次计算区间内的最大值；其时间复杂度比较高。
- 如果有这样的说队列一次滑动窗口（入队和出队），自动得到最大值。那么这个时间的复杂度为哦o(n).
- 有这样的队列吗？
- 我们这样思考，队列中只维护可能成为最值的元素。对于没有成为最值的元素，直接抛弃。
- 检查队头的元素是不是在窗口区间，没有则删除对头元素。一直重复这个过程，直到队头的元素属于这个区间。

## 如何构造单调队列

构造一个单调的队列方法如下：

- 去尾操作 ：队尾元素出队列。当队列有新元素待入队，需要从队尾开始，删除影响队列单调性的元素，维护队列的单调性。(删除一个队尾元素后，就重新判断新的队尾元素)
去尾操作结束后，将该新元素入队列。

- 删头操作 ：队头元素出队列。判断队头元素是否在待求解的区间之内，如果不在，就将其删除。（这个很好理解呀，因为单调队列的队头元素就是待求解区间的极值）

**Tips**
> 我们使使用数组的位置 入队，而不是元素，主要是为了检测队首的元素是否其指定的范围内；



**构造单调递减示例**

原来的序列如下：3 ，1 ，5 ， 7 ，4 ，2 ， 1 其 区间长度 为 3

操作数| 操作 |队列 
---|--|--
3| 直接入队|3
1|队是3比1大，直接入队|3，1
5|1,3队尾都比5小，依次从队尾删除，然后入队|5
7|队尾5比7小，5被删除，7入队|7
4|7比4大，4直接入队|7,4
2|4比2大，直接入队|7,4,2
1|1比2小，1直接入队；**检查队首，7已经不在这个区间了，删除队首7**|4，2,1


其代码表示为：

```java
   public int[] maxSlideWindow(int[] nums,int k){
        int[] result  = new int[nums.length - k +1] ;
        // 单调队列，存储的数组指针
        LinkedList<Integer> q = new LinkedList<>();
        for (int  i = 0;i < nums.length ;i++){
            // 先删队尾
            while (!q.isEmpty()){
                if (nums[q.getLast()] < nums[i]){
                    q.removeLast();
                }else {
                    break;
                }
            }
            // 入队
            q.addLast(i);
            // 范围检查，删队头
            while (!q.isEmpty()){
                if (q.getFirst() < i-k +1){
                    q.removeFirst();
                }else {
                    break;
                }
            }
            // 得出最大值
            if (i >= k -1 ){
                result[i- k +1] = nums[q.getFirst()];
            }
        }
        return result;
    }
```

# 优先队列

优先队列，实际上不属于队列的范畴；应该属于二叉树的范畴。

**题目**
给定一个非空的整数数组，返回其中出现频率前 k 高的元素。


示例 1:

输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
示例 2:

输入: nums = [1], k = 1
输出: [1]
提示：

你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。
你的算法的时间复杂度必须优于 $O(n \log n)$ , n 是数组的大小。
题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。
你可以按任意顺序返回答案